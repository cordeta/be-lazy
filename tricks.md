# Introduction

# Bash

## Useful shortcuts

* `!PATTERN` execute the most recent command in the shell history that begins with PATTERN (*e.g.* `!xm` will likely execute the last `xmgrace` command issued)
* `ctrl + a` go to the beginning of the line
* `ctrl + e` go to the end of the line
* `ctrl + k` cut line after the cursor
* `ctrl + u` cut line before the cursor
* `alt + backspace` cut the word after the cursor
* `ctrl + w` cut the word before the cursor
* `ctrl + y` paste back the last thing you cut
* `ctrl + p` previous command
* `ctrl + n` next command
* `ctrl + r` backward interactive command search
* `ctrl + s` forward interactive command search (**NB:** `stty -ixon` should be first added to .bashrc)

# Plotting

## xmgrace

# SSH

## Escape sequences

[Source](https://lonesysadmin.net/2011/11/08/ssh-escape-sequences-aka-kill-dead-ssh-sessions/amp/)

OpenSSH provides a variety of escape sequences that can be used during SSH sessions, even when the terminal is unresponsive. Typing `~?` (a tilde followed by a question mark) during an SSH session will print the list of available escape sequences which, with my OpenSSH client v7.2, looks like

    ~.   - terminate connection (and any multiplexed sessions)
    ~B   - send a BREAK to the remote system
    ~C   - open a command line
    ~R   - request rekey
    ~V/v - decrease/increase verbosity (LogLevel)
    ~^Z  - suspend ssh
    ~#   - list forwarded connections
    ~&   - background ssh (when waiting for connections to terminate)
    ~?   - this message
    ~~   - send the escape character by typing it twice


**Nota Bene:** `~` (the tilde character) should be the *very* first character on the command line.

# Debugging

## GDB

Here is a a very short and non-comprehensive list of useful GDB commands:

* `break example.c:22` create a breakpoint at line 22 of the file `example.c`.
* `break example.c:22 if i == 100` create a conditional breakpoint. It gets triggered only when the condition is met.
* `where` print the stack-trace after a segfault (or similar error).
* `up/down` move up (down) the stack-trace.
* `ptype` output the type of a variable.
* `info locals` display the name and value of all local variables.
* `disable 1` disable breakpoint number 1.

# Uncategorized

## Making movies

We would like to generate a movie out of a (maybe very long) list of png images. We first create a file containing the list of png files sorted according to the order with which they should appear in the movie. If the names of the files are `img-1.png`, `img-2.png`, *etc.*, this can be accomplished by typing

```
$ ls -1v img-*.png > list.dat
```

The `-v` option is a GNU extension that tells `ls` to order entries according to the natural sorting of the numbers contained in the entry names. If on your system this option is not supported or it does something else (this might be the case on BSD/OSX systems), then you can use the following command

```
$ ls -1 img-*.png | sort -n -t'-' -k 2 > list.dat
```

`-n` applies natural sorting, `-t'-'` tells sort to use dashes as the separators to split the entries it acts on into fields and `-k 2`  to sort according to the value of the second field

A movie of width WIDTH, height HEIGHT and framerate FPS can now be generated by using `mencoder` with the following options:

```
$ mencoder mf://@list.dat -mf w=WIDTH:h=HEIGHT:fps=FPS:type=png -ovc xvid -xvidencopts bitrate=200 -o output.avi
```

The `-ovc xvid` controls the type of output and may not be suitable on all systems (or for all the purposes). The `-xvidencopts bitrate=200` option sets a sort of *overall* quality of the output.

## Adding a fading, rounded border to figures with GIMP

1. Select the whole picture (`ctrl + a`)
2. Shrink the border by an appropriate amount of pixels (Select &rarr; Shrink). I would say no more than 10% of the figure size.
3. Round the selection (Select &rarr; Rounded Rectangle)
4. Invert the selection (`ctrl + i`)
5. Feather the border (Select &rarr; Feather). I usually choose a number similar to the one used in step 2.
6. Delete the selected region (press delete)
7. Turn white into alpha (Colours &rarr; Colour to Alpha)
8. Create a new layer (same width and height as the figure) and put it underneath all other layers
9. Fill the layer with the background colour you want your picture to fade to at the border (usually black)
